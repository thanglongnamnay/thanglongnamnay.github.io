"use strict";import Util from"./util-module.min.js";import Vector from"./Vector.min.js";import Polygon from"./Polygon.min.js";function drawPoint(t,n,o,e,i=5){e=e.toWorld(t),n.fillStyle=o,n.beginPath(),n.arc(e.x,e.y,i,0,2*Math.PI,!0),n.fill()}function drawPolygon(t,n,o,e,i){i=i.map(n=>n.toWorld(t)),n.fillStyle=e,n.strokeStyle=o,n.beginPath();for(let t=0;t<i.length;++t)n.lineTo(i[t].x,i[t].y);n.closePath(),n.fill(),n.stroke()}function drawTriangles(t,n,o,e,i,r){const s=i.length;for(let l=0;l<s;++l)drawPolygon(t,n,o,e,[i[l],i[(l+1)%s],r])}function drawRay(t,n,o,e,i){const r=e.plus(i.normalized().mult(2)),s=r.toWorld(t),l=e.toWorld(t);return n.beginPath(),n.strokeStyle=o,n.moveTo(l.x,l.y),n.lineTo(s.x,s.y),n.fill(),n.stroke(),{point1:e,point2:r}}function getPointsOnRay(t,n){return{point1:t,point2:t.plus(n.normalized().mult(10))}}function checkLineIntersection(t,n,o,e){let i,r,s,l,c,a=t.x,p=t.y,f=n.x,u=n.y,y=o.x,d=o.y,g=e.x,h=e.y,L={x:null,y:null,onLine1:!1,onLine2:!1};return 0==(i=(h-d)*(f-a)-(g-y)*(u-p))?L:(c=(f-a)*(r=p-d)-(u-p)*(s=a-y),r=(l=(g-y)*r-(h-d)*s)/i,s=c/i,L.x=a+r*(f-a),L.y=p+r*(u-p),r>0&&r<1&&(L.onLine1=!0),s>0&&s<1&&(L.onLine2=!0),L.position=Vector(L.x,L.y),L)}function drawRayIntersection(t,n,o,e,i,r){const{point1:s,point2:l}=getPointsOnRay(e,i),c=[];let a;const p=r.length;for(let t=0;t<p;++t){const n=checkLineIntersection(s,l,r[t],r[(t+1)%p]);n.onLine1&&n.onLine2&&(!a||e.distantTo(n.position)<e.distantTo(a))&&(a=n.position)}return a&&c.push(a),c}function getRays(t){const n=2*Math.PI/t,o=[];let e=Vector(1,0);for(let i=0;i<t;++i)o.push(e),e=e.rotate(n);return o}function drawAllRayIntersection(t,n,o,e,i){const r=[];for(const t of i){let{point1:n,point2:i}=getPointsOnRay(o,t);for(const t of e){const e=t.points,r=e.length;for(let t=0;t<r;++t){const s=checkLineIntersection(n,i,e[t],e[(t+1)%r]);s.onLine1&&s.onLine2&&o.distantTo(s.position)<o.distantTo(i)&&(i=s.position)}}r.push(i)}return r}function polygonPairToPointList(t,n){const o=[],e=t.points.length,i=n.points.length;for(let r=0;r<e;++r){const s=(r+1)%e;for(let e=0;e<i;++e){const l=(e+1)%i,c=checkLineIntersection(t.points[r],t.points[s],n.points[e],n.points[l]);c.onLine1&&c.onLine2&&o.push(c.position)}}return o}function selfIntersection(t){const n=t.points.length,o=[];for(let e=0;e<n;++e){const i=(e+1)%n;for(let r=e+1;r<n;++r){const s=(r+1)%n,l=checkLineIntersection(t.points[e],t.points[i],t.points[r],t.points[s]);l.onLine1&&l.onLine2&&o.push(l.position)}}return o}function polygonListToPointList(t){const n=t.length,o=[];for(let e=0;e<n;++e){o.push(...t[e].points,...selfIntersection(t[e]));for(let i=e+1;i<n;++i)o.push(...polygonPairToPointList(t[e],t[i]))}return o}function drawAllRayVertex(t,n,o,e,i,r=!0){let s=e.map(t=>t.minus(o));return s=s.flatMap(t=>[t.rotate(1e-5),t.rotate(-1e-5)]),r&&s.sort((t,n)=>t.angleTo(n)),drawAllRayIntersection(t,n,o,i,s)}function redraw(t,n,o){n.fillStyle="#333",n.fillRect(0,0,t.width,t.height);for(const e of o)e.draw(t,n)}export{drawPoint,drawPolygon,drawTriangles,drawRay,getPointsOnRay,checkLineIntersection,drawRayIntersection,getRays,drawAllRayIntersection,polygonPairToPointList,selfIntersection,polygonListToPointList,drawAllRayVertex,redraw};